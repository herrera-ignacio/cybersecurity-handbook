"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6720],{2355:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>h,toc:()=>c});var a=n(5893),s=n(1151);const o={},i="Hash extension / Length extension",h={id:"cryptography/attacks/hash-extension/README",title:"Hash extension / Length extension",description:"With MD5, SHA1, and other Merkle-Damgard construction hashes, the digest that's returned is really just the internal state of the hash algorithm.",source:"@site/docs/cryptography/attacks/hash-extension/README.md",sourceDirName:"cryptography/attacks/hash-extension",slug:"/cryptography/attacks/hash-extension/",permalink:"/cybersecurity-handbook/cryptography/attacks/hash-extension/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ECB block reordering",permalink:"/cybersecurity-handbook/cryptography/attacks/ecb-block-reordering/"},next:{title:"Padding oracle",permalink:"/cybersecurity-handbook/cryptography/attacks/padding-oracle/"}},r={},c=[{value:"Mitigation",id:"mitigation",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"hash-extension--length-extension",children:"Hash extension / Length extension"}),"\n",(0,a.jsx)(t.p,{children:"With MD5, SHA1, and other Merkle-Damgard construction hashes, the digest that's returned is really just the internal state of the hash algorithm."}),"\n",(0,a.jsx)(t.p,{children:"To hash a given piece of data, the following steps are performed:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Initialize the hash state."}),"\n",(0,a.jsx)(t.li,{children:"For each block of data, mix it into the hash state."}),"\n",(0,a.jsx)(t.li,{children:"Pad the hash."}),"\n",(0,a.jsx)(t.li,{children:"Output the internal hash state."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This means that there's nothing stopping you from simply continuing to add data to the output."}),"\n",(0,a.jsxs)(t.p,{children:["If we have a block of data and the hash that corresponds to it. Let's say its ",(0,a.jsx)(t.code,{children:"hash('secretKey' + data)"}),". With length extension, we can add to the end of ",(0,a.jsx)(t.code,{children:"data"})," without knowing the secret key."]}),"\n",(0,a.jsx)(t.p,{children:"But because there's padding between the old and new data (added by the algorithm) you need to figure out what the padding is. Then yopu simply add the hash padding into the data that goes along with it. The actual hash padding will go at the end and be ignored as it always is, but we need to know how our data is being manipulated."}),"\n",(0,a.jsxs)(t.p,{children:["The process by which you can determine the padding is ",(0,a.jsx)(t.strong,{children:"specific to the algorithm in question"}),", but documented in many places. Search for the algorithm you want to attack."]}),"\n",(0,a.jsx)(t.h2,{id:"mitigation",children:"Mitigation"}),"\n",(0,a.jsxs)(t.p,{children:["If you notice, with an HMAC you cad: ",(0,a.jsx)(t.code,{children:"hash(key + hash(key + message))"}),". Due to the double-hashed nature of the structure, there's no way you can length extend it. When you are hashing a secret with data from the user, you should ",(0,a.jsx)(t.strong,{children:"always use HMAC"})," for this reason."]})]})}function l(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>h,a:()=>i});var a=n(7294);const s={},o=a.createContext(s);function i(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);