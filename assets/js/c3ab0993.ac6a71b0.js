"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6598],{9149:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=s(5893),n=s(1151);const a={},i="Stream cipher reuse / Reused key",o={id:"cryptography/attacks/stream-cipher-reuse/README",title:"Stream cipher reuse / Reused key",description:"* Example with image encryption",source:"@site/docs/cryptography/attacks/stream-cipher-reuse/README.md",sourceDirName:"cryptography/attacks/stream-cipher-reuse",slug:"/cryptography/attacks/stream-cipher-reuse/",permalink:"/cybersecurity-handbook/cryptography/attacks/stream-cipher-reuse/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hashcat",permalink:"/cybersecurity-handbook/cryptography/attacks/password-cracking/hashcat/"},next:{title:"Wordlists",permalink:"/cybersecurity-handbook/cryptography/attacks/wordlists/"}},c={},h=[{value:"Mitigation",id:"mitigation",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"stream-cipher-reuse--reused-key",children:"Stream cipher reuse / Reused key"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://cryptosmith.com/2008/05/31/stream-reuse/",children:"Example with image encryption"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Looking at stream ciphers, we see that we generate a stream of random bytes which are XORed with the plaintext to produce ciphertext."}),"\n",(0,r.jsx)(t.p,{children:"Any time you feed a given key into a stream cipher, it's always going to generate the same output bytes. This is expected and it's why decryption works exactly the same as encryption."}),"\n",(0,r.jsx)(t.p,{children:"Let's consider the case of two pieces of data (A and B) being encrypted with the same key K. The stream cipher orudces a string of bits C(K) the same length as the messages, let's call it S."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:"A_enc[0] = S[0] ^ A[0]\nB_enc[0] = S[0] ^ B[0]\nA_enc[1] = S[1] ^ A[1]\nB_enc[1] = S[1] ^ B[1]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Because of the fact that both A and B are being XORed with the same random stream, it is trivial to unroll this operation."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:"(A[0] ^ S[0]) ^ (B[0] ^ S[0]) == A[0] ^ B[0]\nThus A_enc[0] ^ B_enc[0] == A[0] ^ B[0]\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This is due to xor being ",(0,r.jsx)(t.em,{children:"commutative"}),", and has the property that ",(0,r.jsx)(t.code,{children:"X xor X = 0"})," (self-inverse), so:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:"(E(A) xor E(B) = (A xor S) xor (B xor S) = A xor B xor S xor S) = A xor B\n"})}),"\n",(0,r.jsx)(t.p,{children:"By XORing the two ciphertext together, we get the XOR of the plaintext, the random stream cancels out entirely!"}),"\n",(0,r.jsx)(t.p,{children:"Even if neither message is known, as long as both messages are in a natural language, such a cipher can often be broken by paper-and-pencil methods."}),"\n",(0,r.jsx)(t.h2,{id:"mitigation",children:"Mitigation"}),"\n",(0,r.jsx)(t.p,{children:"The most important precautions are:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Keys must never be used twice"}),"\n",(0,r.jsx)(t.li,{children:"Valid decryption should never be relied on to indicate authenticity"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This is not a problem for modern stream ciphers like ",(0,r.jsx)(t.strong,{children:"eSTREAM"}),", which take a nonce along with the key. This means that as long as you don't reuse a given key-nonce pair, you're safe. However, the most common stream cipher you'll see is ",(0,r.jsx)(t.strong,{children:"RC4"}),", which is lacking this feature."]}),"\n",(0,r.jsxs)(t.p,{children:["One way to avoid this problem is to use an ",(0,r.jsx)(t.strong,{children:"Initialization Vector (IV)"}),", sent in the clear, that is combined with a secret master key to create a one-time key for the stream cipher. This is done in several common systems that use the popular stream cipher ",(0,r.jsx)(t.strong,{children:"RC4"}),", such as ",(0,r.jsx)(t.strong,{children:"WEP"}),", ",(0,r.jsx)(t.strong,{children:"WPA"}),", and ",(0,r.jsx)(t.strong,{children:"Ciphersaber"}),'. One of the many problems with WEP was that its IV was too short, 24 bits. This meant that there was a high likelihood that the same IV would be used twice if more than a few thousand packets were sent with the same master key, subjecting the packets with duplicated IV to the key reuse attack. This problem was fixed in WPA by changing the "master" key frequently.']})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>i});var r=s(7294);const n={},a=r.createContext(n);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);