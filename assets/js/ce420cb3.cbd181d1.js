"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7401],{6873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(5893),o=n(1151);const r={},i="Padding oracle",s={id:"cryptography/attacks/padding-oracle/README",title:"Padding oracle",description:"Through a Padding Oracle Attack, an attacker is able to decrypt information, without knowing the encryption key.",source:"@site/docs/cryptography/attacks/padding-oracle/README.md",sourceDirName:"cryptography/attacks/padding-oracle",slug:"/cryptography/attacks/padding-oracle/",permalink:"/cybersecurity-handbook/cryptography/attacks/padding-oracle/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hash extension / Length extension",permalink:"/cybersecurity-handbook/cryptography/attacks/hash-extension/"},next:{title:"Stream cipher reuse / Reused key",permalink:"/cybersecurity-handbook/cryptography/attacks/stream-cipher-reuse/"}},c={},l=[{value:"Usage",id:"usage",level:2},{value:"Mitigation",id:"mitigation",level:2}];function d(e){const t={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"padding-oracle",children:"Padding oracle"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Through a Padding Oracle Attack, an attacker is able to decrypt information, without knowing the encryption key."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Padding oracle attacks come into play when you have ",(0,a.jsx)(t.strong,{children:"CBC-mode"})," data that is ",(0,a.jsx)(t.strong,{children:"padded with PKCS#7"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If the server behaves differently when decrypting improperly padded data than properly padded data, this is an ",(0,a.jsx)(t.strong,{children:"oracle"}),", you can send it data and know whether or not it's correctly padded."]}),"\n",(0,a.jsx)(t.p,{children:"Because of CBC-mode, we know that flipping a bit in one CBC ciphertext block will cause that bit position to be flipped in the next block's plaintext. Because of this, a padding oracle can allow us to use the server to completely decrypt data without knowing the key ourselves."}),"\n",(0,a.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(t.p,{children:"We start from the last byte of the second-to-last block. Modifications there will affect the last byte of the last block of the data."}),"\n",(0,a.jsxs)(t.p,{children:["Our goal is to determine what byte of ciphertext in block N-1 will cause the plaintext of block N to be 0x1 when XORed together. Once we know this, we know that the plaintext of that byte in block N is ",(0,a.jsx)(t.code,{children:"Cipher ^ 0x1"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"So let's say we have this data:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-txt",children:"hacker101\\x07\\x07\\x07\\x07\\x07\\x07\\x07\n"})}),"\n",(0,a.jsx)(t.p,{children:"We get out some ciphertext blob, for the purposes of this explanation, we'll say it's:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-txt",children:"deadbeefcafe0123\nfeedface456789ab\n"})}),"\n",(0,a.jsx)(t.p,{children:"To decrypt the second block, you decrypt it using your cipher, then you XOR that with the first ciphertext block to get your plaintext."}),"\n",(0,a.jsxs)(t.p,{children:["So with our example, we know that when you decrypt the block ",(0,a.jsx)(t.code,{children:"feedface456789ab"}),", you must get something where the ",(0,a.jsx)(t.code,{children:"last byte ^ 0x23"})," (last byte of the previous block) == 0x07."]}),"\n",(0,a.jsx)(t.p,{children:"Any other value will cause a padding error, except one! If instead of 0x07 our last byte became 0x01, that's valid too. That means there's only one byte of padding."}),"\n",(0,a.jsx)(t.p,{children:"So if we try all 255 other possible values for the last byte of our plaintext, we know that one of them will certainly not give us a padding error. Once we know this value, we simply XOR that byte with 0x03 (to change the final padding to 0x02) and repeat the same thing for the byte before it. One of them will make it so the last two bytes are 0x02 0x02."}),"\n",(0,a.jsx)(t.p,{children:"By perfroming this across all the bytes in a block, then walking back from there along the blocks, we can find the plaintext value of every single byte of this data."}),"\n",(0,a.jsx)(t.h2,{id:"mitigation",children:"Mitigation"}),"\n",(0,a.jsxs)(t.p,{children:["Add ",(0,a.jsx)(t.strong,{children:"MAC"})," to your data after encryption, and validate the MAC before decryption."]}),"\n",(0,a.jsx)(t.p,{children:"It's imperative that you do not differentiate between errors. A user should never know why decryption has failed, if it's due to improper padding, that should look the same as having a bad digest or anything else."})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>i});var a=n(7294);const o={},r=a.createContext(o);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);